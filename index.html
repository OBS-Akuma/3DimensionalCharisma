<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3DimensionalCharisma â€“ Knife Game</title>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden; background: black; height: 100%;
      cursor: pointer;
      color: white;
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
    }
    #crosshair {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin-left: -10px;
      margin-top: -10px;
      pointer-events: none;
      z-index: 100;
    }
    #crosshair:before, #crosshair:after {
      content: '';
      position: absolute;
      background: white;
    }
    #crosshair:before {
      left: 50%;
      top: 0;
      width: 2px;
      height: 100%;
      margin-left: -1px;
    }
    #crosshair:after {
      top: 50%;
      left: 0;
      height: 2px;
      width: 100%;
      margin-top: -1px;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      z-index: 110;
      font-size: 18px;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 6px;
    }
  </style>
</head>
<body>
  <div id="crosshair"></div>
  <div id="info">Zombies remaining: <span id="zcount">0</span></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script>
    const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.5, 5);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const light = new THREE.HemisphereLight(0xffffff, 0x444444, 1.2);
scene.add(light);

// Floor
const floorSize = 20;
const floor = new THREE.Mesh(
  new THREE.PlaneGeometry(floorSize, floorSize),
  new THREE.MeshStandardMaterial({ color: 0x888888 })
);
floor.rotation.x = -Math.PI / 2;
scene.add(floor);

// Walls
const wallHeight = 2;
const wallThickness = 0.5;
const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });

const walls = [];

const frontWall = new THREE.Mesh(
  new THREE.BoxGeometry(floorSize, wallHeight, wallThickness),
  wallMaterial
);
frontWall.position.set(0, wallHeight / 2, floorSize / 2);
scene.add(frontWall);
walls.push(frontWall);

const backWall = new THREE.Mesh(
  new THREE.BoxGeometry(floorSize, wallHeight, wallThickness),
  wallMaterial
);
backWall.position.set(0, wallHeight / 2, -floorSize / 2);
scene.add(backWall);
walls.push(backWall);

const leftWall = new THREE.Mesh(
  new THREE.BoxGeometry(wallThickness, wallHeight, floorSize),
  wallMaterial
);
leftWall.position.set(-floorSize / 2, wallHeight / 2, 0);
scene.add(leftWall);
walls.push(leftWall);

const rightWall = new THREE.Mesh(
  new THREE.BoxGeometry(wallThickness, wallHeight, floorSize),
  wallMaterial
);
rightWall.position.set(floorSize / 2, wallHeight / 2, 0);
scene.add(rightWall);
walls.push(rightWall);

// Player variables
let isLocked = false;
let yaw = 0;
let pitch = 0;
const pitchLimit = Math.PI / 2 - 0.1;
const baseSpeed = 0.1;
const keys = {};

// Physics variables for gravity and jump
let velocityY = 0;
const gravity = -30;
const jumpSpeed = 10;
const groundHeight = 1.5;
let canJump = false;

// Zombies
const zombieCount = 5;
const zombies = [];

// Create zombie meshes with positions around the map
function spawnZombies() {
  for(let i = 0; i < zombieCount; i++) {
    const zombie = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1.5, 1),
      new THREE.MeshStandardMaterial({ color: 0xff0000 })
    );
    // Random position on the floor, avoiding spawn near player start
    let x, z;
    do {
      x = (Math.random() - 0.5) * floorSize * 0.9;
      z = (Math.random() - 0.5) * floorSize * 0.9;
    } while (Math.sqrt((x - camera.position.x)**2 + (z - camera.position.z)**2) < 5);

    zombie.position.set(x, 0.75, z);
    zombie.health = 1;
    scene.add(zombie);
    zombies.push(zombie);
  }
  updateZombieCount();
}

function updateZombieCount() {
  document.getElementById('zcount').textContent = zombies.length;
}

spawnZombies();

// Add knife to camera
const knifeGeometry = new THREE.BoxGeometry(0.1, 0.02, 0.5);
const knifeMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.7, roughness: 0.2 });
const knife = new THREE.Mesh(knifeGeometry, knifeMaterial);
knife.position.set(0.3, -0.3, -0.5);
camera.add(knife);
scene.add(camera);

// Player health
let playerHP = 100;
const maxHP = 100;

// Update health display
function updateHP() {
  let hpEl = document.getElementById('hp');
  if (!hpEl) {
    hpEl = document.createElement('div');
    hpEl.id = 'hp';
    hpEl.style.position = 'fixed';
    hpEl.style.bottom = '10px';
    hpEl.style.left = '10px';
    hpEl.style.color = 'white';
    hpEl.style.fontSize = '18px';
    hpEl.style.background = 'rgba(0,0,0,0.5)';
    hpEl.style.padding = '8px 12px';
    hpEl.style.borderRadius = '6px';
    document.body.appendChild(hpEl);
  }
  hpEl.textContent = `HP: ${playerHP} / ${maxHP}`;
}
updateHP();

let gameOver = false;

function endGame() {
  gameOver = true;
  alert('Game Over! You died.');
  // Optionally, reload or reset game
  // location.reload();
}

// Pointer lock controls
window.addEventListener('click', () => {
  if (!isLocked && !gameOver) {
    document.body.requestPointerLock();
  }
});

document.addEventListener('pointerlockchange', () => {
  isLocked = document.pointerLockElement === document.body;
});

document.addEventListener('mousemove', e => {
  if (!isLocked) return;

  const sensitivity = 0.002;
  yaw -= e.movementX * sensitivity;
  pitch -= e.movementY * sensitivity;
  pitch = Math.max(-pitchLimit, Math.min(pitchLimit, pitch));
});

window.addEventListener('keydown', e => {
  if (gameOver) return;
  keys[e.code] = true;

  if (e.code === 'Space' && canJump) {
    velocityY = jumpSpeed;
    canJump = false;
  }

  if (e.code === 'KeyE') {
    attackZombies();
  }
});

window.addEventListener('keyup', e => {
  keys[e.code] = false;
});

// Simple collision detection with walls
function checkCollision(newPos) {
  const radius = 0.4;
  for (const wall of walls) {
    const minX = wall.position.x - wall.geometry.parameters.width / 2 - radius;
    const maxX = wall.position.x + wall.geometry.parameters.width / 2 + radius;
    const minZ = wall.position.z - wall.geometry.parameters.depth / 2 - radius;
    const maxZ = wall.position.z + wall.geometry.parameters.depth / 2 + radius;

    if (
      newPos.x > minX && newPos.x < maxX &&
      newPos.z > minZ && newPos.z < maxZ
    ) {
      return true;
    }
  }
  return false;
}

// Attack function - remove zombies in range
function attackZombies() {
  if (gameOver) return;
  const knifeRange = 1.5;
  const playerPos = camera.position;

  for (let i = zombies.length - 1; i >= 0; i--) {
    const zombie = zombies[i];
    const dist = zombie.position.distanceTo(playerPos);
    if (dist <= knifeRange) {
      scene.remove(zombie);
      zombies.splice(i, 1);
      updateZombieCount();
    }
  }
}

// Zombie attack variables
const zombieAttackRange = 1.2;
const zombieAttackDamage = 10;
const zombieAttackCooldown = 1.5; // seconds
let lastZombieAttackTime = 0;

let prevTime = performance.now();

function animate() {
  requestAnimationFrame(animate);

  if (gameOver) {
    renderer.render(scene, camera);
    return;
  }

  const time = performance.now();
  const delta = (time - prevTime) / 1000;
  prevTime = time;

  zombies.forEach(zombie => {
    // Move zombie toward player
    const dir = new THREE.Vector3().subVectors(camera.position, zombie.position);
    dir.y = 0;
    const distance = dir.length();

    if (distance > 0.1) {
      dir.normalize();
      const speed = 0.7 * delta;
      const newPos = zombie.position.clone().add(dir.multiplyScalar(speed));

      if (!checkCollision(newPos)) {
        zombie.position.copy(newPos);
      }
    }

    // Zombie attacks player if close enough and cooldown passed
    if (distance <= zombieAttackRange) {
      if (time / 1000 - lastZombieAttackTime > zombieAttackCooldown) {
        playerHP -= zombieAttackDamage;
        updateHP();
        lastZombieAttackTime = time / 1000;

        if (playerHP <= 0) {
          endGame();
        }
      }
    }
  });

  const forwardDir = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const rightDir = new THREE.Vector3(Math.sin(yaw - Math.PI / 2), 0, Math.cos(yaw - Math.PI / 2));

  let moveVector = new THREE.Vector3();

  if (isLocked) {
    if (keys['KeyW']) moveVector.add(forwardDir);
    if (keys['KeyS']) moveVector.sub(forwardDir);
    if (keys['KeyA']) moveVector.sub(rightDir);
    if (keys['KeyD']) moveVector.add(rightDir);
  }

  if (moveVector.length() > 0) {
    moveVector.normalize();
    moveVector.multiplyScalar(0.1);
  }

  const newPosition = camera.position.clone();
  newPosition.x += moveVector.x;
  newPosition.z += moveVector.z;

  if (!checkCollision(newPosition)) {
    camera.position.x = newPosition.x;
    camera.position.z = newPosition.z;
  }

  // Gravity & jump
  velocityY += gravity * delta;
  camera.position.y += velocityY * delta;

  if (camera.position.y <= groundHeight) {
    camera.position.y = groundHeight;
    velocityY = 0;
    canJump = true;
  }

  const lookDir = new THREE.Vector3(
    Math.cos(pitch) * Math.sin(yaw),
    Math.sin(pitch),
    Math.cos(pitch) * Math.cos(yaw)
  );
  const lookAtPos = new THREE.Vector3().addVectors(camera.position, lookDir);
  camera.lookAt(lookAtPos);

  renderer.render(scene, camera);
}

animate();

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
  </script>
</body>
</html>
