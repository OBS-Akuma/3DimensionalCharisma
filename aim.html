<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Aim Trainer with Auto Pointer Lock on Start</title>
  <style>
    /* same styles as before except: remove lock/unlock buttons from #settings */
    html, body {
      margin: 0;
      overflow: hidden;
      height: 100%;
      background: #111;
      font-family: Arial, sans-serif;
      color: white;
      user-select: none;
      cursor: none;
    }
    #settings {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.75);
      padding: 15px;
      border-radius: 8px;
      width: 260px;
      z-index: 20;
    }
    #settings label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
    }
    #settings input[type=range], #settings select, #settings input[type=text] {
      width: 100%;
      margin-bottom: 10px;
      cursor: pointer;
      box-sizing: border-box;
      padding: 5px;
      border-radius: 4px;
      border: none;
    }
    #scoreboard, #timer {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.75);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 20px;
      z-index: 20;
      user-select: none;
    }
    #timer {
      top: 50px;
      font-size: 18px;
    }
    #controls {
      margin-top: 10px;
      text-align: center;
    }
    #controls button {
      background: #222;
      color: white;
      border: none;
      padding: 8px 15px;
      margin: 0 5px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
    }
    #controls button:hover {
      background: #444;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 30px;
      height: 30px;
      margin-left: -15px;
      margin-top: -15px;
      pointer-events: none;
      z-index: 15;
    }
    #crosshair:before, #crosshair:after {
      content: '';
      position: absolute;
      background: white;
    }
    #crosshair:before {
      left: 14px;
      top: 0;
      width: 2px;
      height: 30px;
    }
    #crosshair:after {
      top: 14px;
      left: 0;
      width: 30px;
      height: 2px;
    }
    #customCursor {
      position: fixed;
      width: 32px;
      height: 32px;
      pointer-events: none;
      z-index: 30;
      mix-blend-mode: difference;
      display: none;
    }
  </style>
</head>
<body>
  <div id="settings">
    <!-- same inputs as before, but remove lock/unlock pointer buttons -->
    <label>Targets Count: <span id="targetCountVal">5</span></label>
    <input type="range" id="targetCount" min="1" max="20" value="5" />

    <label>Target Size: <span id="targetSizeVal">1</span></label>
    <input type="range" id="targetSize" min="0.2" max="3" step="0.1" value="1" />

    <label>Spawn Speed (sec): <span id="spawnSpeedVal">2</span></label>
    <input type="range" id="spawnSpeed" min="0.2" max="5" step="0.1" value="2" />

    <label>Difficulty:</label>
    <select id="difficulty">
      <option value="easy" selected>Easy (red)</option>
      <option value="medium">Medium (orange)</option>
      <option value="hard">Hard (yellow)</option>
    </select>

    <label>Session Length (seconds): <span id="sessionLengthVal">60</span></label>
    <input type="range" id="sessionLength" min="10" max="300" value="60" />

    <label>Mouse Sensitivity: <span id="sensitivityVal">1</span></label>
    <input type="range" id="sensitivity" min="0.1" max="5" step="0.1" value="1" />

    <label>Custom Background URL:</label>
    <input type="text" id="bgUrl" placeholder="https://example.com/bg.jpg" />

    <label>Custom Cursor URL (32x32 px recommended):</label>
    <input type="text" id="cursorUrl" placeholder="https://example.com/cursor.png" />

    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <div id="scoreboard">Score: 0</div>
  <div id="timer">Time: 60</div>
  <div id="crosshair"></div>
  <img id="customCursor" src="" alt="Custom Cursor" />

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let raycaster, mouse;
    let targets = [];
    let score = 0;
    let spawnInterval;
    let sessionLength = 60;
    let timeLeft = sessionLength;
    let timerInterval;
    let gameRunning = false;

    let sensitivity = 1;
    let pointerLocked = false;

    // Virtual camera rotation state for pointer lock control
    let rotationX = 0; // up/down
    let rotationY = 0; // left/right

    // Settings elements
    const targetCountInput = document.getElementById('targetCount');
    const targetSizeInput = document.getElementById('targetSize');
    const spawnSpeedInput = document.getElementById('spawnSpeed');
    const difficultySelect = document.getElementById('difficulty');
    const sessionLengthInput = document.getElementById('sessionLength');
    const sensitivityInput = document.getElementById('sensitivity');
    const bgUrlInput = document.getElementById('bgUrl');
    const cursorUrlInput = document.getElementById('cursorUrl');

    const scoreDisplay = document.getElementById('scoreboard');
    const timerDisplay = document.getElementById('timer');
    const targetCountVal = document.getElementById('targetCountVal');
    const targetSizeVal = document.getElementById('targetSizeVal');
    const spawnSpeedVal = document.getElementById('spawnSpeedVal');
    const sessionLengthVal = document.getElementById('sessionLengthVal');
    const sensitivityVal = document.getElementById('sensitivityVal');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');

    const customCursorImg = document.getElementById('customCursor');

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 10;

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('click', onClick, false);

      document.addEventListener('pointerlockchange', onPointerLockChange, false);
      document.addEventListener('mousemove', onMouseMove, false);

      updateSettingsValues();
      createTargets(parseInt(targetCountInput.value));
      updateScore(0);
      updateTimer(sessionLength);
      stopGame();
      animate();
    }

    function updateSettingsValues() {
      targetCountVal.textContent = targetCountInput.value;
      targetSizeVal.textContent = targetSizeInput.value;
      spawnSpeedVal.textContent = spawnSpeedInput.value;
      sessionLengthVal.textContent = sessionLengthInput.value;
      sensitivityVal.textContent = sensitivityInput.value;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createTarget(size) {
      const geometry = new THREE.SphereGeometry(size, 16, 16);
      const material = new THREE.MeshBasicMaterial({color: getColorForDifficulty()});
      const target = new THREE.Mesh(geometry, material);
      
      randomizeTargetPosition(target);
      scene.add(target);
      return target;
    }

    function getColorForDifficulty() {
      switch(difficultySelect.value) {
        case 'medium': return 0xffa500; // orange
        case 'hard': return 0xffff00;   // yellow
        default: return 0xff4444;       // red for easy
      }
    }

    function randomizeTargetPosition(target) {
      const range = 8;
      target.position.set(
        (Math.random() - 0.5) * range,
        (Math.random() - 0.5) * range,
        (Math.random() - 0.5) * range
      );
    }

    function createTargets(count) {
      clearTargets();
      const size = parseFloat(targetSizeInput.value);
      for(let i=0; i < count; i++) {
        const target = createTarget(size);
        targets.push(target);
      }
    }

    function clearTargets() {
      for(let t of targets) {
        scene.remove(t);
        t.geometry.dispose();
        t.material.dispose();
      }
      targets = [];
    }

    function updateScore(value) {
      score = value;
      scoreDisplay.textContent = `Score: ${score}`;
    }

    function updateTimer(value) {
      timeLeft = value;
      timerDisplay.textContent = `Time: ${timeLeft}`;
    }

    function onClick(event) {
      if (!gameRunning || !pointerLocked) return; // only when game running & pointer locked

      // Use center of screen for aiming since pointer is locked
      raycaster.setFromCamera(new THREE.Vector2(0,0), camera);

      const intersects = raycaster.intersectObjects(targets);
      if(intersects.length > 0) {
        const hitTarget = intersects[0].object;
        score++;
        updateScore(score);

        hitTarget.material.color.set(getColorForDifficulty());
        randomizeTargetPosition(hitTarget);
      }
    }

    function spawnTarget() {
      if (!gameRunning) return;
      
      if(targets.length < parseInt(targetCountInput.value)) {
        const size = parseFloat(targetSizeInput.value);
        const newTarget = createTarget(size);
        targets.push(newTarget);
      }
    }

    function startSpawning() {
      clearInterval(spawnInterval);
      const speed = parseFloat(spawnSpeedInput.value) * 1000;
      spawnInterval = setInterval(() => {
        if (!gameRunning) return;
        while(targets.length > parseInt(targetCountInput.value)) {
          const t = targets.pop();
          scene.remove(t);
          t.geometry.dispose();
          t.material.dispose();
        }
        if(targets.length < parseInt(targetCountInput.value)) {
          spawnTarget();
        }
      }, speed);
    }

    function countdown() {
      if (!gameRunning) return;
      if(timeLeft > 0) {
        timeLeft--;
        timerDisplay.textContent = `Time: ${timeLeft}`;
      } else {
        stopGame();
        alert(`Time's up! Your score: ${score}`);
      }
    }

    // New startGame requests pointer lock first, then starts game if granted
    function startGame() {
      if(gameRunning) return;
      renderer.domElement.requestPointerLock();
    }

    // This listens for pointer lock change to start or cancel game start
    function onPointerLockChange() {
      pointerLocked = document.pointerLockElement === renderer.domElement;
      if(pointerLocked) {
        console.log("Pointer locked");
        customCursorImg.style.display = 'block';
        runGameStart(); // start timer and spawning now that pointer is locked
      } else {
        console.log("Pointer unlocked");
        customCursorImg.style.display = 'none';
        pauseGame();
      }
    }

    // Actually start the timer and spawning after pointer lock is confirmed
    function runGameStart() {
      gameRunning = true;
      startSpawning();
      timerInterval = setInterval(countdown, 1000);
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      targetCountInput.disabled = true;
      targetSizeInput.disabled = true;
      spawnSpeedInput.disabled = true;
      difficultySelect.disabled = true;
      sessionLengthInput.disabled = true;
      sensitivityInput.disabled = true;
      bgUrlInput.disabled = true;
      cursorUrlInput.disabled = true;
    }

    function pauseGame() {
      if(!gameRunning) return;
      gameRunning = false;
      clearInterval(spawnInterval);
      clearInterval(timerInterval);
      startBtn.disabled = false;
      pauseBtn.disabled = true;
    }

    function stopGame() {
      gameRunning = false;
      clearInterval(spawnInterval);
      clearInterval(timerInterval);
      updateTimer(parseInt(sessionLengthInput.value));
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      targetCountInput.disabled = false;
      targetSizeInput.disabled = false;
      spawnSpeedInput.disabled = false;
      difficultySelect.disabled = false;
      sessionLengthInput.disabled = false;
      sensitivityInput.disabled = false;
      bgUrlInput.disabled = false;
      cursorUrlInput.disabled = false;
    }

    function resetGame() {
      pauseGame();
      updateScore(0);
      createTargets(parseInt(targetCountInput.value));
      updateTimer(parseInt(sessionLengthInput.value));
    }

    function animate() {
      requestAnimationFrame(animate);

      targets.forEach(t => {
        t.rotation.x += 0.01;
        t.rotation.y += 0.01;
      });

      renderer.render(scene, camera);

      if (pointerLocked) {
        customCursorImg.style.display = 'block';
        customCursorImg.style.left = window.innerWidth/2 - customCursorImg.width/2 + 'px';
        customCursorImg.style.top = window.innerHeight/2 - customCursorImg.height/2 + 'px';
      } else {
        customCursorImg.style.display = 'none';
      }
    }

    function onMouseMove(event) {
      if(!pointerLocked) return;
      const movementX = event.movementX || 0;
      const movementY = event.movementY || 0;

      const sens = parseFloat(sensitivityInput.value);

      rotationY -= movementX * 0.002 * sens;
      rotationX -= movementY * 0.002 * sens;

      const maxRotationX = Math.PI/2 * 0.95;
      if(rotationX > maxRotationX) rotationX = maxRotationX;
      if(rotationX < -maxRotationX) rotationX = -maxRotationX;

      camera.rotation.x = rotationX;
      camera.rotation.y = rotationY;
    }

    // UI Event listeners same as before
    targetCountInput.addEventListener('input', () => {
      targetCountVal.textContent = targetCountInput.value;
      if (!gameRunning) createTargets(parseInt(targetCountInput.value));
    });
    targetSizeInput.addEventListener('input', () => {
      targetSizeVal.textContent = targetSizeInput.value;
      if (!gameRunning) {
        targets.forEach(t => {
          t.scale.setScalar(parseFloat(targetSizeInput.value));
        });
      }
    });
    spawnSpeedInput.addEventListener('input', () => {
      spawnSpeedVal.textContent = spawnSpeedInput.value;
      if(gameRunning) startSpawning();
    });
    difficultySelect.addEventListener('change', () => {
      if(!gameRunning) {
        targets.forEach(t => {
          t.material.color.set(getColorForDifficulty());
        });
      }
    });
    sessionLengthInput.addEventListener('input', () => {
      sessionLengthVal.textContent = sessionLengthInput.value;
      if(!gameRunning) updateTimer(parseInt(sessionLengthInput.value));
    });
    sensitivityInput.addEventListener('input', () => {
      sensitivityVal.textContent = sensitivityInput.value;
    });

    bgUrlInput.addEventListener('change', () => {
      const url = bgUrlInput.value.trim();
      if(url) {
        document.body.style.backgroundImage = `url(${url})`;
        document.body.style.backgroundSize = 'cover';
        document.body.style.backgroundPosition = 'center';
      } else {
        document.body.style.backgroundImage = '';
      }
    });

    cursorUrlInput.addEventListener('change', () => {
      const url = cursorUrlInput.value.trim();
      if(url) {
        customCursorImg.src = url;
      } else {
        customCursorImg.src = '';
        customCursorImg.style.display = 'none';
      }
    });

    startBtn.addEventListener('click', startGame);
    pauseBtn.addEventListener('click', pauseGame);
    resetBtn.addEventListener('click', resetGame);

    init();
  </script>
</body>
</html>
