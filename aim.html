<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Aim Trainer Enhanced</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      font-family: Arial, sans-serif;
      color: white;
      user-select: none;
    }
    #settings {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.75);
      padding: 15px;
      border-radius: 8px;
      width: 240px;
      z-index: 10;
    }
    #settings label {
      display: block;
      margin-bottom: 6px;
      font-size: 14px;
    }
    #settings input[type=range], #settings select {
      width: 100%;
      margin-bottom: 10px;
      cursor: pointer;
    }
    #scoreboard, #timer {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.75);
      padding: 10px 15px;
      border-radius: 8px;
      font-size: 20px;
      z-index: 10;
      user-select: none;
    }
    #timer {
      top: 50px;
      font-size: 18px;
    }
    #controls {
      margin-top: 10px;
      text-align: center;
    }
    #controls button {
      background: #222;
      color: white;
      border: none;
      padding: 8px 15px;
      margin: 0 5px;
      font-size: 16px;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
    }
    #controls button:hover {
      background: #444;
    }
    #crosshair {
      position: fixed;
      left: 50%;
      top: 50%;
      width: 30px;
      height: 30px;
      margin-left: -15px;
      margin-top: -15px;
      pointer-events: none;
      z-index: 9;
    }
    #crosshair:before, #crosshair:after {
      content: '';
      position: absolute;
      background: white;
    }
    #crosshair:before {
      left: 14px;
      top: 0;
      width: 2px;
      height: 30px;
    }
    #crosshair:after {
      top: 14px;
      left: 0;
      width: 30px;
      height: 2px;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="settings">
    <label>Targets Count: <span id="targetCountVal">5</span></label>
    <input type="range" id="targetCount" min="1" max="20" value="5" />

    <label>Target Size: <span id="targetSizeVal">1</span></label>
    <input type="range" id="targetSize" min="0.2" max="3" step="0.1" value="1" />

    <label>Spawn Speed (sec): <span id="spawnSpeedVal">2</span></label>
    <input type="range" id="spawnSpeed" min="0.2" max="5" step="0.1" value="2" />

    <label>Difficulty:</label>
    <select id="difficulty">
      <option value="easy" selected>Easy (red)</option>
      <option value="medium">Medium (orange)</option>
      <option value="hard">Hard (yellow)</option>
    </select>

    <label>Session Length (seconds): <span id="sessionLengthVal">60</span></label>
    <input type="range" id="sessionLength" min="10" max="300" value="60" />

    <div id="controls">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="resetBtn">Reset</button>
    </div>
  </div>

  <div id="scoreboard">Score: 0</div>
  <div id="timer">Time: 60</div>
  <div id="crosshair"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
  <script>
    let scene, camera, renderer;
    let raycaster, mouse;
    let targets = [];
    let score = 0;
    let spawnInterval;
    let sessionLength = 60;
    let timeLeft = sessionLength;
    let timerInterval;
    let gameRunning = false;
    
    // Settings elements
    const targetCountInput = document.getElementById('targetCount');
    const targetSizeInput = document.getElementById('targetSize');
    const spawnSpeedInput = document.getElementById('spawnSpeed');
    const difficultySelect = document.getElementById('difficulty');
    const sessionLengthInput = document.getElementById('sessionLength');

    const scoreDisplay = document.getElementById('scoreboard');
    const timerDisplay = document.getElementById('timer');
    const targetCountVal = document.getElementById('targetCountVal');
    const targetSizeVal = document.getElementById('targetSizeVal');
    const spawnSpeedVal = document.getElementById('spawnSpeedVal');
    const sessionLengthVal = document.getElementById('sessionLengthVal');

    const startBtn = document.getElementById('startBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const resetBtn = document.getElementById('resetBtn');

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 10;

      renderer = new THREE.WebGLRenderer({antialias:true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();

      window.addEventListener('resize', onWindowResize, false);
      window.addEventListener('click', onClick, false);

      updateSettingsValues();
      createTargets(parseInt(targetCountInput.value));
      updateScore(0);
      updateTimer(sessionLength);
      stopGame();
      animate();
    }

    function updateSettingsValues() {
      targetCountVal.textContent = targetCountInput.value;
      targetSizeVal.textContent = targetSizeInput.value;
      spawnSpeedVal.textContent = spawnSpeedInput.value;
      sessionLengthVal.textContent = sessionLengthInput.value;
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function createTarget(size) {
      const geometry = new THREE.SphereGeometry(size, 16, 16);
      const material = new THREE.MeshBasicMaterial({color: getColorForDifficulty()});
      const target = new THREE.Mesh(geometry, material);
      
      randomizeTargetPosition(target);
      scene.add(target);
      return target;
    }

    function getColorForDifficulty() {
      switch(difficultySelect.value) {
        case 'medium': return 0xffa500; // orange
        case 'hard': return 0xffff00;   // yellow
        default: return 0xff4444;       // red for easy
      }
    }

    function randomizeTargetPosition(target) {
      const range = 8;
      target.position.set(
        (Math.random() - 0.5) * range,
        (Math.random() - 0.5) * range,
        (Math.random() - 0.5) * range
      );
    }

    function createTargets(count) {
      clearTargets();
      const size = parseFloat(targetSizeInput.value);
      for(let i=0; i < count; i++) {
        const target = createTarget(size);
        targets.push(target);
      }
    }

    function clearTargets() {
      for(let t of targets) {
        scene.remove(t);
        t.geometry.dispose();
        t.material.dispose();
      }
      targets = [];
    }

    function updateScore(value) {
      score = value;
      scoreDisplay.textContent = `Score: ${score}`;
    }

    function updateTimer(value) {
      timeLeft = value;
      timerDisplay.textContent = `Time: ${timeLeft}`;
    }

    function onClick(event) {
      if (!gameRunning) return; // ignore clicks if game is paused/stopped

      event.preventDefault();

      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      const intersects = raycaster.intersectObjects(targets);
      if(intersects.length > 0) {
        const hitTarget = intersects[0].object;
        score++;
        updateScore(score);

        // Respawn hit target with new color in case difficulty changed mid-game
        hitTarget.material.color.set(getColorForDifficulty());
        randomizeTargetPosition(hitTarget);
      }
    }

    function spawnTarget() {
      if (!gameRunning) return;
      
      if(targets.length < parseInt(targetCountInput.value)) {
        const size = parseFloat(targetSizeInput.value);
        const newTarget = createTarget(size);
        targets.push(newTarget);
      }
    }

    function startSpawning() {
      clearInterval(spawnInterval);
      const speed = parseFloat(spawnSpeedInput.value) * 1000;
      spawnInterval = setInterval(() => {
        if (!gameRunning) return;
        // Remove excess targets if needed
        while(targets.length > parseInt(targetCountInput.value)) {
          const t = targets.pop();
          scene.remove(t);
          t.geometry.dispose();
          t.material.dispose();
        }
        if(targets.length < parseInt(targetCountInput.value)) {
          spawnTarget();
        }
      }, speed);
    }

    function countdown() {
      if (!gameRunning) return;
      if(timeLeft > 0) {
        timeLeft--;
        timerDisplay.textContent = `Time: ${timeLeft}`;
      } else {
        stopGame();
      }
    }

    function startGame() {
      if(gameRunning) return;
      gameRunning = true;
      startSpawning();
      timerInterval = setInterval(countdown, 1000);
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      targetCountInput.disabled = true;
      targetSizeInput.disabled = true;
      spawnSpeedInput.disabled = true;
      difficultySelect.disabled = true;
      sessionLengthInput.disabled = true;
    }

    function pauseGame() {
      if(!gameRunning) return;
      gameRunning = false;
      clearInterval(spawnInterval);
      clearInterval(timerInterval);
      startBtn.disabled = false;
      pauseBtn.disabled = true;
    }

    function stopGame() {
      gameRunning = false;
      clearInterval(spawnInterval);
      clearInterval(timerInterval);
      updateTimer(parseInt(sessionLengthInput.value));
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      targetCountInput.disabled = false;
      targetSizeInput.disabled = false;
      spawnSpeedInput.disabled = false;
      difficultySelect.disabled = false;
      sessionLengthInput.disabled = false;
    }

    function resetGame() {
      pauseGame();
      updateScore(0);
      createTargets(parseInt(targetCountInput.value));
      updateTimer(parseInt(sessionLengthInput.value));
    }

    function animate() {
      requestAnimationFrame(animate);

      targets.forEach(t => {
        t.rotation.x += 0.01;
        t.rotation.y += 0.01;
      });

      renderer.render(scene, camera);
    }

    // UI Event listeners
    targetCountInput.addEventListener('input', () => {
      targetCountVal.textContent = targetCountInput.value;
      if (!gameRunning) createTargets(parseInt(targetCountInput.value));
    });
    targetSizeInput.addEventListener('input', () => {
      targetSizeVal.textContent = targetSizeInput.value;
      if (!gameRunning) {
        targets.forEach(t => {
          t.scale.setScalar(parseFloat(targetSizeInput.value));
        });
      }
    });
    spawnSpeedInput.addEventListener('input', () => {
      spawnSpeedVal.textContent = spawnSpeedInput.value;
      if(gameRunning) startSpawning();
    });
    difficultySelect.addEventListener('change', () => {
      if(!gameRunning) {
        targets.forEach(t => {
          t.material.color.set(getColorForDifficulty());
        });
      }
    });
    sessionLengthInput.addEventListener('input', () => {
      sessionLengthVal.textContent = sessionLengthInput.value;
      if(!gameRunning) updateTimer(parseInt(sessionLengthInput.value));
    });
    startBtn.addEventListener('click', startGame);
    pauseBtn.addEventListener('click', pauseGame);
    resetBtn.addEventListener('click', resetGame);

    init();
  </script>
</body>
</html>
